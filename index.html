<!DOCTYPE html>
<html lang="da">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Interaktivt Eventyr: Gojo, Sukuna og det Store Hav</title>
   <script src="https://cdn.tailwindcss.com"></script>
   <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
   <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
   <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
   <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
   <!-- Firebase SDKs -->
   <script type="module">
       import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
       import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
       import { getFirestore, doc, getDoc, setDoc, collection, addDoc, onSnapshot, query, orderBy, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

       const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
       const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
       const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

       // Initialiser Firebase app med det samme
       const app = initializeApp(firebaseConfig);
       const auth = getAuth(app);
       const db = getFirestore(app);

       // Eksponer Firebase objekter globalt for React script
       window.firebase = {
           app, auth, db,
           initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
           getFirestore, doc, getDoc, setDoc, collection, addDoc, onSnapshot, query, orderBy, limit
       };
       window.appId = appId;
       window.firebaseConfig = firebaseConfig;
       window.initialAuthToken = initialAuthToken;

       // H√•ndter initial autentificering og s√¶t global klar-flag
       onAuthStateChanged(auth, async (user) => {
           if (!user) { // Hvis ingen bruger er autentificeret endnu
               if (initialAuthToken) {
                   await signInWithCustomToken(auth, initialAuthToken);
               } else {
                   await signInAnonymously(auth);
               }
           }
           // S√¶t global userId efter at auth-tilstanden er bestemt
           window.firebase.userId = auth.currentUser?.uid || crypto.randomUUID();
           window.firebase.isReady = true; // S√¶t et flag for React til at vide, at Firebase er klar
           console.log("Firebase initialiseret og auth-tilstand bestemt. Bruger ID:", window.firebase.userId);
           document.dispatchEvent(new CustomEvent('firebaseReady')); // Send event til React
       });
   </script>
   <!-- PDF Generation Libraries -->
   <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

   <link rel="preconnect" href="https://fonts.googleapis.com">
   <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
   <link href="https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@400;600;700&family=Bangers&display=swap" rel="stylesheet">
   <!-- Chosen Palette: Seaside Serenity -->
   <!-- Application Structure Plan: App'en er nu en React SPA, der bevarer den interaktive kortstruktur over "Stjerne√∏havet". Brugeren starter med en introduktion, navigerer via klikbare mark√∏rer p√• kortet for at √•bne kapitelpaneler. Hvert kapitel har sekventielle sektioner med tekst og visualiseringer, der afsl√∏res via en "N√¶ste"-knap. En "Skab Dit Eget Eventyr"-funktion giver brugeren mulighed for at tilpasse og generere nye kapitler, som gemmes i Firestore og tilf√∏jes dynamisk til kortet. React-komponenter er brugt til at modularisere UI og logik, hvilket forbedrer vedligeholdelse og ydeevne. Firebase h√•ndterer datalagring af brugerdefinerede kapitler og progression. -->
   <!-- Visualization & Content Choices: Visualiseringerne er valgt for at underst√∏tte kapitlets tema og opdateres dynamisk. Doughnut-diagrammer viser progression (mod, koralrevsfarver). Interaktive knapper simulerer valg (Skygge√∏en). Enkel tekstboks med ikoner giver information (Magisk Kompas). S√∏jlediagrammer sammenligner v√¶rdier (St√∏rste Skat). Alle visualiseringer er implementeret med Chart.js eller ren HTML/CSS/JS inden for React-komponenter. Unicode-ikoner bruges til visuel identifikation. Animationer i anime/manga-stil (f.eks. fade-ins, pops, slides) er tilf√∏jet for at forbedre engagement og visuel appel. -->
   <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
   <style>
       body {
           font-family: 'Nunito Sans', sans-serif;
           overflow-x: hidden; /* Forhindrer vandret scrolling p√• hele siden */
       }
       .bg-sea-sand { background-color: #F4F1DE; }
       .bg-sea-water { background-color: #E0F7FA; }
       .text-sea-deep { color: #003B46; }
       .text-sea-coral { color: #E94F37; }
       .btn-coral {
           background-color: #E94F37;
           color: white;
           border: 2px solid black; /* Added black border */
       }
       .btn-coral:hover { background-color: #d8452e; transform: translateY(-2px); box-shadow: 0 6px 10px rgba(0,0,0,0.2); }
       .btn-coral:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
       .btn-ocean {
           background-color: #07575B;
           color: white;
           border: 2px solid black; /* Added black border */
       }
       .btn-ocean:hover { background-color: #064a4d; transform: translateY(-2px); box-shadow: 0 6px 10px rgba(0,0,0,0.2); }
       .btn-ocean:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
       
       /* Roblox-style buttons */
       .roblox-btn {
           background-color: #00A2FF; /* Roblox blue */
           color: white;
           font-family: 'Bangers', cursive;
           font-size: 1.5rem;
           padding: 1rem 2rem;
           border-radius: 12px; /* Lidt afrundede, blok-agtige hj√∏rner */
           border: 4px solid black; /* M√∏rkere bl√• kant */
           box-shadow: 0 8px 0 black, 0 12px 15px rgba(0,0,0,0.3); /* Stablet skygge for dybde */
           transition: all 0.1s ease-in-out;
           cursor: pointer;
           text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
           letter-spacing: 1px;
       }
       .roblox-btn:hover {
           transform: translateY(-2px);
           box-shadow: 0 10px 0 black, 0 14px 18px rgba(0,0,0,0.4);
       }
       .roblox-btn:active {
           transform: translateY(4px);
           box-shadow: 0 4px 0 black, 0 6px 8px rgba(0,0,0,0.2);
       }
       .roblox-btn.green {
           background-color: #00E676; /* Roblox green */
           border-color: black;
           box-shadow: 0 8px 0 black, 0 12px 15px rgba(0,0,0,0.3);
       }
       .roblox-btn.green:hover {
           box-shadow: 0 10px 0 black, 0 14px 18px rgba(0,0,0,0.4);
       }
       .roblox-btn.green:active {
           box-shadow: 0 4px 0 black, 0 6px 8px rgba(0,0,0,0.2);
       }
       .roblox-btn.red {
           background-color: #FF3D00; /* Roblox red */
           border-color: black;
           box-shadow: 0 8px 0 black, 0 12px 15px rgba(0,0,0,0.3);
       }
       .roblox-btn.red:hover {
           box-shadow: 0 10px 0 black, 0 14px 18px rgba(0,0,0,0.4);
       }
       .roblox-btn.red:active {
           box-shadow: 0 4px 0 black, 0 6px 8px rgba(0,0,0,0.2);
       }

       #main-app {
           flex-grow: 1;
           position: relative;
           width: 100%;
           height: 100vh; /* S√∏rg for, at den fylder hele viewport-h√∏jden */
           overflow: hidden; /* Hold kortet selv fra at rulle */
           display: flex;
           flex-direction: column;
       }

       #map-container {
           background-image: url('https://placehold.co/1200x800/E0F7FA/003B46?text=Stjerne%C3%B8havet');
           background-size: cover;
           background-position: center;
           width: 100%;
           height: 100%;
           position: absolute; /* S√∏rg for at den d√¶kker hele main-app */
           top: 0;
           left: 0;
       }
       .map-marker {
           transform: translate(-50%, -50%) scale(1);
           transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), background-color 0.2s ease-in-out;
           box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
       }
       .map-marker:hover {
           transform: translate(-50%, -50%) scale(1.2);
           box-shadow: 0 8px 12px rgba(0, 0, 0, 0.2);
       }
       .chapter-panel, .customize-panel, .full-adventure-panel {
           transform: translateX(100%);
           opacity: 0;
           transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.5s ease-in-out;
           overflow-y: auto; /* Eksplicit sikring af lodret scrolling for paneler */
           -webkit-overflow-scrolling: touch; /* For j√¶vn scrolling p√• iOS */
       }
       .chapter-panel.is-open, .customize-panel.is-open, .full-adventure-panel.is-open {
           transform: translateX(0);
           opacity: 1;
       }
       .chart-container {
           position: relative;
           margin: auto;
           height: 250px; /* Fast h√∏jde for konsistens, responsiv bredde */
           width: 100%; /* Tag fuld bredde af for√¶lder */
       }
       .icon-large {
           font-size: 3rem;
           line-height: 1;
           margin-bottom: 1rem;
       }
       .path-choice-btn {
           transition: background-color 0.3s ease, transform 0.1s ease;
           transform: scale(1);
       }
       .path-choice-btn:active {
           transform: scale(0.95);
       }
       .path-choice-btn.selected {
           transform: scale(1.05);
           border: 2px solid #E94F37;
       }
       .path-choice-btn.correct {
           background-color: #28a745;
       }
       .path-choice-btn.incorrect {
           background-color: #dc3545;
       }
       #luca-avatar {
           transform: translateY(0);
           animation: float 3s ease-in-out infinite;
           transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
       }
       #luca-avatar:hover {
           transform: scale(1.05) translateY(-5px);
           box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
       }
       @keyframes float {
           0% { transform: translateY(0px); }
           50% { transform: translateY(-5px); }
           100% { transform: translateY(0px); }
       }
       #avatar-message {
           opacity: 0;
           transform: translateY(10px);
           transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
       }
       #avatar-message.is-visible {
           opacity: 1;
           transform: translateY(0);
       }
       #background-canvas {
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           z-index: -2;
       }
       #dynamic-wallpaper {
           position: fixed;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           z-index: -1;
           display: flex;
           align-items: center;
           justify-content: center;
           text-align: center;
           opacity: 0;
           transition: opacity 1s ease-in-out;
       }
       #wallpaper-image {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           object-fit: cover;
           filter: brightness(60%) blur(2px);
       }
       #wallpaper-quote-container {
           position: relative;
           z-index: 1;
           background-color: rgba(0, 0, 0, 0.5);
           padding: 1.5rem;
           border-radius: 0.75rem;
           max-width: 80%;
           box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
           transform: scale(0.9);
           animation: pop-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
       }
       #wallpaper-quote {
           font-family: 'Bangers', cursive; /* Anime/Manga style font */
           color: white;
           font-size: 1.5rem;
           font-weight: bold;
           font-style: italic;
           text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
       }
       @media (min-width: 768px) {
           #wallpaper-quote {
               font-size: 2.5rem;
           }
       }
       .loader {
           border: 4px solid #f3f3f3;
           border-top: 4px solid #E94F37;
           border-radius: 50%;
           width: 40px;
           height: 40px;
           animation: spin 1s linear infinite;
           margin: 20px auto;
       }
       @keyframes spin {
           0% { transform: rotate(0deg); }
           100% { transform: rotate(360deg); }
       }
       @keyframes pop-in {
           0% { transform: scale(0.5); opacity: 0; }
           100% { transform: scale(1); opacity: 1; }
       }
       .fade-in {
           opacity: 0;
           animation: fadeIn 0.5s ease-in forwards;
       }
       @keyframes fadeIn {
           from { opacity: 0; }
           to { opacity: 1; }
       }
       .image-gallery {
           display: grid;
           grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* Responsivt grid */
           gap: 1rem;
           margin-top: 1.5rem;
           justify-items: center; /* Centrer billeder i deres grid-celler */
       }
       .image-gallery img {
           width: 100%;
           height: 120px; /* Fast h√∏jde for konsistens */
           object-fit: cover;
           border-radius: 0.5rem;
           box-shadow: 0 4px 8px rgba(0,0,0,0.1);
       }
       @media (min-width: 768px) {
           .image-gallery {
               grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
           }
           .image-gallery img {
               height: 150px;
           }
       }
       /* PDF specific styling */
       .pdf-content {
           background-color: white; /* S√∏rg for hvid baggrund for PDF */
           color: black;
           padding: 20px;
           font-family: 'Nunito Sans', sans-serif;
       }
       .pdf-chapter {
           margin-bottom: 30px;
           padding-bottom: 20px;
           border-bottom: 1px dashed #ccc;
       }
       .pdf-chapter:last-child {
           border-bottom: none;
       }
       .pdf-chapter h2 {
           font-size: 24px;
           color: #003B46;
           margin-bottom: 10px;
       }
       .pdf-chapter p {
           font-size: 14px;
           line-height: 1.6;
           margin-bottom: 10px;
       }
       .pdf-chapter .image-gallery img {
           width: 100px;
           height: 100px;
           margin-right: 10px;
           object-fit: cover;
           border-radius: 5px;
       }
   </style>
</head>
<body class="bg-sea-sand text-sea-deep">
   <div id="root"></div>

   <script type="text/babel">
       const { useState, useEffect, useRef, useCallback } = React;
       const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
               getFirestore, doc, getDoc, setDoc, collection, addDoc, onSnapshot, query, orderBy, limit } = window.firebase;

       // Historiedata
       const storyData = [
           {
               title: "Havets Hjerte",
               icon: "‚ù§Ô∏è",
               intro: "I dette kapitel l√¶rer Luca, at sand navigation ikke kun handler om kort, men om at m√¶rke verden og finde modet i sig selv til at se igennem udfordringer som t√¶t t√•ge.",
               markerPos: { top: '65%', left: '75%' },
               sections: [
                   {
                       text: `Gojo l√¶rte Luca om stjernerne, mens Sukuna l√¶rte ham om havets farer. En aften rullede en t√¶t t√•ge ind over M√∏rke Hvirvelstr√∏mme. Luca m√¶rkede frygten, men huskede Gojos ord. Han lukkede √∏jnene, koncentrerede sig og m√¶rkede, hvor str√∏mmen var svagest.`,
                       vizUpdate: { type: 'doughnut', data: { label: "Lucas Mod", initialValue: 30, buttonText: "Navig√©r gennem t√•gen" } }
                   },
                   {
                       text: `Han guidede dem sikkert igennem. Senere fandt de Havets Hjerte √∏en, som var beskyttet af illusioner. Ved at lytte til sit hjerte fandt Luca den rigtige vej til √∏en og til en lysende krystal ‚Äì Havets Hjerte. Den gav ham en f√∏lelse af ro og styrke.`,
                       vizUpdate: { type: 'doughnut_update', data: { finalValue: 100 } }
                   }
               ]
           },
           {
               title: "Skygge√∏ens Illusioner",
               icon: "‚òÅÔ∏è",
               intro: "Her st√•r Luca overfor en pr√∏ve i at skelne virkelighed fra fantasi. Han m√• stole p√• sin intuition for at undg√• de f√¶lder, som Skygge√∏ens magiske t√•ge l√¶gger for ham.",
               markerPos: { top: '35%', left: '25%' },
               sections: [
                   {
                       text: `Rejsen gik til den mystiske Skygge√∏, der var skjult i en t√•ge fuld af illusioner. Stemmer hviskede, og skr√¶mmende syner dukkede op. Et falsk skibsvrag r√•bte p√• hj√¶lp, men Sukuna advarede om f√¶lden.`,
                       vizUpdate: { type: 'pathChoice' }
                   },
                   {
                       text: `Luca huskede sin tr√¶ning, lukkede √∏jnene og m√¶rkede efter et m√∏nster i t√•gen i stedet for at se. Han fandt et hul i t√•gens cirkul√¶re bev√¶gelse, og de fandt √∏en. Her l√¶rte he, at illusioner kun har magt, hvis man tror p√• dem.`,
                       vizUpdate: { type: 'pathChoice_reveal' }
                   }
               ]
           },
           {
               title: "Det Magiske Kompas",
               icon: "üß≠",
               intro: "P√• Skygge√∏en finder Luca et kompas, der ikke peger nord, men mod den *sikreste* vej. Lektionen er, at den rigtige vej ikke altid er den nemmeste, og at sand styrke er at overvinde frygt.",
               markerPos: { top: '45%', left: '55%' },
               sections: [
                   {
                       text: `P√• Skygge√∏en fandt de Den Gamle Mariners Kompas. Det havde ingen n√•l, men en sv√¶vende, lysende kugle. For at f√• det til at virke, m√•tte Luca forestille sig den v√¶rste storm og √∏nske at finde en sikker vej.`,
                       vizUpdate: { type: 'info', data: { text: "Forestil dig den v√¶rste storm...", icon: "üå™Ô∏è" } }
                   },
                   {
                       text: `Kompasset pegede mod de farlige Hviskende Rev. Sukuna forklarede, at kompasset ikke viste den nemme, men den *sikreste* vej. Luca forstod, at det handlede om at stole p√• sin d√∏mmekraft, selv n√•r vejen s√• skr√¶mmende ud.`,
                       vizUpdate: { type: 'info_update', data: { text: "Den sande styrke er at stole p√• sin d√∏mmekraft.", icon: "‚ú®" } }
                   }
               ]
           },
           {
               title: "Koralrevets Tristhed",
               icon: "üê†",
               intro: "Dette kapitel handler om empati. Luca opdager, at et helt √∏kosystem lider p√• grund af √©t enkelt v√¶sens sorg, og at heling starter med at forst√• og vise venlighed.",
               markerPos: { top: '80%', left: '40%' },
               sections: [
                   {
                       text: `Under havets overflade fandt de et smukt koralrev, der var ved at blive gr√•t p√• grund af en m√∏rk skygge. Havfruen Coralina forklarede, at det var en forbandelse af tristhed.`,
                       vizUpdate: { type: 'colorChangeDoughnut', data: { label: "Revets Farver", buttonText: "Del Sukunas Sang" } }
                   },
                   {
                       text: `Luca brugte sin evne til at m√¶rke f√∏lelser og fandt kilden: en lille, gr√• klovnfisk, der havde mistet sin familie. For at redde revet, m√•tte de f√∏rst hele klovfiskens hjerte. Sukuna gav den, overraskende nok, en magisk musling med en sang om h√•b. Da klovfisken blev glad, vendte farverne tilbage til revet.`,
                       vizUpdate: { type: 'colorChangeDoughnut_update' }
                   }
               ]
           },
           {
               title: "Den St√∏rste Skat",
               icon: "üí∞",
               intro: "Eventyrets afslutning afsl√∏rer den sande mening med at v√¶re en stor marine. Det handler ikke om guld, men om godhed og om at efterlade verden et bedre sted.",
               markerPos: { top: '25%', left: '80%' },
               sections: [
                   {
                       text: `Den Syngende Hval guidede dem med sin sang til en skjult passage. Luca l√¶rte at navigere efter stjernerne ved at lytte til hvalens melodi. Passagen f√∏rte til Skatte√∏en.`,
                       vizUpdate: { type: 'barChart', data: { label1: "Guld & Juveler", label2: "En God Gerning", initialValue1: 40, initialValue2: 10 } }
                   },
                   {
                       text: `Her fandt de ikke guld, men en magisk, boblende kilde, der kunne helbrede havet. Gojo forklarede, at den st√∏rste skat ikke er rigdom, men at g√∏re en god gerning. Luca forstod, at at v√¶re en sand helt handlede om at beskytte og hj√¶lpe andre.`,
                       vizUpdate: { type: 'barChart_update', data: { finalValue1: 40, finalValue2: 95 } }
                   }
               ]
           }
       ];

       // Baggrundsdata for tapet
       const wallpaperData = [
           { quote: "Havet er smukt, men ogs√• n√•desl√∏st.", imageUrl: "https://placehold.co/1920x1080/003B46/E0F7FA?text=Det+Vilde+Hav" },
           { quote: "En illusion kan kun narre dem, der tror p√• den.", imageUrl: "https://placehold.co/1920x1080/E94F37/F4F1DE?text=Illusionernes+%C3%98" },
           { quote: "Den sande styrke er at overvinde frygten i dit eget hjerte.", imageUrl: "https://placehold.co/1920x1080/07575B/FFFFFF?text=Modets+Rejse" },
           { quote: "Den st√∏rste skat er at g√∏re en god gerning.", imageUrl: "https://placehold.co/1920x1080/6c757d/E94F37?text=Godhedens+Kilde" },
           { quote: "Hvert vindpust, hver b√∏lge har sin egen historie at fort√¶lle.", imageUrl: "https://placehold.co/1920x1080/003B46/E0F7FA?text=Havets+Sprog" },
           { quote: "Luca, du har fundet din indre navigat√∏r.", imageUrl: "https://placehold.co/1920x1080/E94F37/003B46?text=Lucas+Indre+Kompas" }
       ];

       // --- Firebase Service ---
       const FirebaseService = {
           db: null,
           auth: null,
           userId: null,
           appId: window.appId,
           isReady: false,

           init(setAuthReady) {
               this.db = window.firebase.db;
               this.auth = window.firebase.auth;
               
               // Lyt efter firebaseReady event, som sendes fra den globale script-blok
               document.addEventListener('firebaseReady', () => {
                   this.userId = window.firebase.userId;
                   this.isReady = window.firebase.isReady;
                   setAuthReady(true); // Opdater React-tilstand
                   console.log("Firebase klar i React. Bruger ID:", this.userId);
               });
           },

           async loadUserProgress() {
               if (!this.isReady || !this.db || !this.userId) return null;
               try {
                   const progressDocRef = doc(this.db, 'artifacts', this.appId, 'users', this.userId, 'progress', 'luca_story_progress');
                   const progressDocSnap = await getDoc(progressDocRef);
                   return progressDocSnap.exists() ? progressDocSnap.data() : null;
               } catch (e) {
                   console.error("Fejl ved indl√¶sning af brugerfremskridt:", e);
                   return null;
               }
           },

           async saveUserProgress(progressData) {
               if (!this.isReady || !this.db || !this.userId) return;
               try {
                   const progressDocRef = doc(this.db, 'artifacts', this.appId, 'users', this.userId, 'progress', 'luca_story_progress');
                   await setDoc(progressDocRef, progressData, { merge: true });
                   console.log("Brugerfremskridt gemt.");
               } catch (e) {
                   console.error("Fejl ved lagring af brugerfremskridt:", e);
               }
           },

           subscribeToCustomChapters(callback) {
               if (!this.isReady || !this.db || !this.userId) return;
               const customChaptersColRef = collection(this.db, 'artifacts', this.appId, 'users', this.userId, 'custom_chapters');
               const q = query(customChaptersColRef, orderBy('timestamp', 'desc'));
               return onSnapshot(q, (snapshot) => {
                   const newChapters = [];
                   snapshot.docChanges().forEach(change => {
                       if (change.type === "added") {
                           newChapters.push({ id: change.doc.id, ...change.doc.data() });
                       }
                   });
                   if (newChapters.length > 0) {
                       callback(newChapters);
                   }
               }, (error) => {
                   console.error("Fejl ved abonnement p√• brugerdefinerede kapitler:", error);
               });
           },

           async addGeneratedChapter(chapterData) {
               if (!this.isReady || !this.db || !this.userId) {
                   throw new Error("Firebase er ikke klar. Pr√∏v igen om et √∏jeblik.");
               }
               const customChaptersColRef = collection(this.db, 'artifacts', this.appId, 'users', this.userId, 'custom_chapters');
               const docRef = await addDoc(customChaptersColRef, chapterData);
               return docRef.id;
           }
       };

       // --- Canvas Renderer Component ---
       const BackgroundCanvas = () => {
           const canvasRef = useRef(null);
           const bubbles = useRef([]);
           const waves = useRef([]);
           const animationFrameId = useRef(null);

           const resizeCanvas = useCallback(() => {
               const canvas = canvasRef.current;
               if (canvas) {
                   canvas.width = window.innerWidth;
                   canvas.height = window.innerHeight;
                   bubbles.current = [];
                   waves.current = [];
                   createBubbles(50);
                   createWaves(3);
               }
           }, []);

           const createBubbles = (count) => {
               const canvas = canvasRef.current;
               for (let i = 0; i < count; i++) {
                   const x = Math.random() * canvas.width;
                   const y = Math.random() * canvas.height;
                   const radius = Math.random() * 5 + 2;
                   const speed = Math.random() * 0.5 + 0.1;
                   bubbles.current.push(new Bubble(x, y, radius, speed));
               }
           };

           const createWaves = (count) => {
               const canvas = canvasRef.current;
               for (let i = 0; i < count; i++) {
                   const y = (canvas.height / (count + 1)) * (i + 1);
                   const amplitude = Math.random() * 10 + 5;
                   const frequency = Math.random() * 0.01 + 0.005;
                   const speed = Math.random() * 0.02 + 0.01;
                   waves.current.push(new Wave(y, amplitude, frequency, speed));
               }
           };

           const animateBackground = useCallback(() => {
               const ctx = canvasRef.current.getContext('2d');
               ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
               
               waves.current.forEach(wave => {
                   wave.update();
                   wave.draw(ctx);
               });

               bubbles.current.forEach(bubble => {
                   bubble.update();
                   bubble.draw(ctx);
               });

               animationFrameId.current = requestAnimationFrame(animateBackground);
           }, []);

           useEffect(() => {
               resizeCanvas();
               window.addEventListener('resize', resizeCanvas);
               animateBackground();

               return () => {
                   window.removeEventListener('resize', resizeCanvas);
                   if (animationFrameId.current) {
                       cancelAnimationFrame(animationFrameId.current);
                   }
               };
           }, [resizeCanvas, animateBackground]);

           class Bubble {
               constructor(x, y, radius, speed) {
                   this.x = x;
                   this.y = y;
                   this.radius = radius;
                   this.speed = speed;
                   this.opacity = Math.random() * 0.5 + 0.2;
               }
               draw(ctx) {
                   ctx.beginPath();
                   ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                   ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                   ctx.fill();
               }
               update() {
                   this.y -= this.speed;
                   if (this.y < -this.radius) {
                       this.y = canvasRef.current.height + this.radius;
                       this.x = Math.random() * canvasRef.current.width;
                   }
               }
           }

           class Wave {
               constructor(y, amplitude, frequency, speed) {
                   this.y = y;
                   this.amplitude = amplitude;
                   this.frequency = frequency;
                   this.speed = speed;
                   this.offset = Math.random() * Math.PI * 2;
               }
               draw(ctx) {
                   ctx.beginPath();
                   ctx.moveTo(0, this.y + Math.sin(this.offset) * this.amplitude);
                   for (let i = 0; i < canvasRef.current.width; i++) {
                       ctx.lineTo(i, this.y + Math.sin(i * this.frequency + this.offset) * this.amplitude);
                   }
                   ctx.strokeStyle = `rgba(0, 59, 70, 0.1)`;
                   ctx.lineWidth = 2;
                   ctx.stroke();
               }
               update() {
                   this.offset += this.speed;
               }
           }

           return <canvas id="background-canvas" ref={canvasRef}></canvas>;
       };

       // --- Luca Avatar Component ---
       const LucaAvatar = () => {
           const [lucaAvatarUrl, setLucaAvatarUrl] = useState("https://placehold.co/100x100/FFD700/000000?text=Luca"); // Initial placeholder
           const [avatarLoading, setAvatarLoading] = useState(true);
           const [avatarError, setAvatarError] = useState('');

           useEffect(() => {
               const generateAvatar = async () => {
                   setAvatarLoading(true);
                   setAvatarError('');
                   const prompt = "A young boy named Luca with short blonde hair and glasses, wearing casual clothes, in a child-friendly anime style, full body shot, standing, happy expression.";
                   const payload = { instances: { prompt: prompt }, parameters: { "sampleCount": 1 } };
                   const apiKey = ""; // Canvas provides this at runtime.
                   const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

                   try {
                       const response = await fetch(apiUrl, {
                           method: 'POST',
                           headers: { 'Content-Type': 'application/json' },
                           body: JSON.stringify(payload)
                       });
                       const result = await response.json();

                       if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                           const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                           setLucaAvatarUrl(imageUrl);
                       } else {
                           console.error("Uventet Imagen API-svarstruktur for avatar:", result);
                           setAvatarError("Kunne ikke generere avatar. Bruger standard.");
                       }
                   } catch (error) {
                       console.error("Fejl ved generering af avatar:", error);
                       setAvatarError("Fejl ved generering af avatar. Bruger standard.");
                   } finally {
                       setAvatarLoading(false);
                   }
               };
               generateAvatar();
           }, []); // Run once on mount

           const handleClick = () => {
               setShowMessage(true);
               setTimeout(() => setShowMessage(false), 1500);
           };

           const [showMessage, setShowMessage] = useState(false); // State for the message

           return (
               <div id="luca-avatar-container" className="absolute top-4 left-4 z-40">
                   <img
                       id="luca-avatar"
                       src={lucaAvatarUrl}
                       alt="Luca Avatar"
                       className="rounded-full border-4 border-white shadow-lg cursor-pointer"
                       onClick={handleClick}
                   />
                   {avatarLoading && <div className="loader absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-8 h-8"></div>}
                   {avatarError && <p className="text-red-500 text-xs mt-1">{avatarError}</p>}
                   <div
                       id="avatar-message"
                       className={`absolute top-full left-1/2 -translate-x-1/2 mt-2 bg-sea-deep text-white text-sm px-3 py-1 rounded-lg whitespace-nowrap ${showMessage ? 'is-visible' : ''}`}
                   >
                       Hej, jeg er Luca!
                   </div>
               </div>
           );
       };

       // --- Dynamic Wallpaper Component ---
       const DynamicWallpaper = ({ wallpaperData }) => {
           const [currentWallpaperIndex, setCurrentWallpaperIndex] = useState(0);
           const wallpaperIntervalId = useRef(null);
           const [isVisible, setIsVisible] = useState(false);

           const changeWallpaper = useCallback(() => {
               setIsVisible(false);
               setTimeout(() => {
                   setCurrentWallpaperIndex(prevIndex => (prevIndex + 1) % wallpaperData.length);
                   setIsVisible(true);
               }, 1000); // Vent p√• fade ud
           }, [wallpaperData]);

           useEffect(() => {
               // Start animation, n√•r komponent mountes
               setIsVisible(true);
               wallpaperIntervalId.current = setInterval(changeWallpaper, 10000);

               return () => {
                   if (wallpaperIntervalId.current) {
                       clearInterval(wallpaperIntervalId.current);
                   }
               };
           }, [changeWallpaper]);

           const currentWallpaper = wallpaperData[currentWallpaperIndex];

           return (
               <div id="dynamic-wallpaper" className={isVisible ? 'opacity-100' : 'opacity-0'}>
                   <img id="wallpaper-image" src={currentWallpaper.imageUrl} alt="Dynamisk Baggrundsbillede" />
                   <div id="wallpaper-quote-container">
                       <p id="wallpaper-quote">{currentWallpaper.quote}</p>
                   </div>
               </div>
           );
       };

       // --- Visualization Components ---
       const DoughnutChart = ({ data, onAction }) => {
           const canvasRef = useRef(null);
           const chartInstance = useRef(null);
           const [buttonDisabled, setButtonDisabled] = useState(false);

           useEffect(() => {
               if (chartInstance.current) {
                   chartInstance.current.destroy();
               }
               const ctx = canvasRef.current.getContext('2d');
               chartInstance.current = new Chart(ctx, {
                   type: 'doughnut',
                   data: {
                       labels: [data.label, ''],
                       datasets: [{
                           data: [data.initialValue, 100 - data.initialValue],
                           backgroundColor: ['#07575B', '#003B4620'],
                           borderColor: '#E0F7FA',
                           borderWidth: 4,
                       }]
                   },
                   options: {
                       responsive: true,
                       maintainAspectRatio: false,
                       cutout: '70%',
                       plugins: { legend: { display: false }, tooltip: { enabled: false } }
                   }
               });
               setButtonDisabled(false); // Nulstil knap-tilstand ved ny chart render
           }, [data]);

           const handleClick = () => {
               if (chartInstance.current) {
                   chartInstance.current.data.datasets[0].data = [data.finalValue, 100 - data.finalValue];
                   chartInstance.current.update();
                   setButtonDisabled(true);
                   onAction("Modet vokser! üí™");
               }
           };

           return (
               <div className="text-center fade-in">
                   {/* Tilf√∏jet responsive bredde og centrering til chart container */}
                   <div className="chart-container w-full max-w-xs sm:max-w-sm md:max-w-md mx-auto">
                       <canvas ref={canvasRef}></canvas>
                   </div>
                   <button onClick={handleClick} disabled={buttonDisabled} className="btn-ocean py-2 px-4 rounded-lg mt-4 block mx-auto">
                       {buttonDisabled ? onAction : data.buttonText}
                   </button>
               </div>
           );
       };

       const PathChoice = ({ onAction }) => {
           const [result, setResult] = useState('');
           const [selectedPath, setSelectedPath] = useState(null);

           const handleChoice = (choice) => {
               setSelectedPath(choice);
               if (choice === 'truth') {
                   setResult('Korrekt! Luca stoler p√• sin intuition. ‚ú®');
               } else {
                   setResult('Forkert! Det er en f√¶lde.');
               }
               onAction(); // Meddel for√¶lder, at interaktion er sket
           };

           return (
               <div className="text-center fade-in">
                   <p className="mb-4 font-semibold">Hvilken vej stoler Luca p√•?</p>
                   <div className="flex flex-col md:flex-row justify-center gap-4">
                       <button
                           onClick={() => handleChoice('illusion')}
                           className={`path-choice-btn btn-ocean py-2 px-4 rounded-lg shadow-md ${selectedPath === 'illusion' ? 'selected incorrect' : ''}`}
                           disabled={selectedPath !== null}
                       >
                           Illusionens Sti üëª
                       </button>
                       <button
                           onClick={() => handleChoice('truth')}
                           className={`path-choice-btn btn-ocean py-2 px-4 rounded-lg shadow-md ${selectedPath === 'truth' ? 'selected correct' : ''}`}
                           disabled={selectedPath !== null}
                       >
                           Sandhedens Sti ‚úÖ
                       </button>
                   </div>
                   <p id="path-result" className="mt-4 font-bold text-sea-coral">{result}</p>
               </div>
           );
       };

       const ColorChangeDoughnut = ({ data, onAction }) => {
           const canvasRef = useRef(null);
           const chartInstance = useRef(null);
           const [buttonDisabled, setButtonDisabled] = useState(false);

           useEffect(() => {
               if (chartInstance.current) {
                   chartInstance.current.destroy();
               }
               const ctx = canvasRef.current.getContext('2d');
               chartInstance.current = new Chart(ctx, {
                   type: 'doughnut',
                   data: {
                       labels: ['Tristhed', 'Gl√¶de'],
                       datasets: [{
                           data: [80, 20],
                           backgroundColor: ['#6c757d', '#003B4620'],
                           borderColor: '#E0F7FA',
                           borderWidth: 4
                       }]
                   },
                   options: {
                       responsive: true,
                       maintainAspectRatio: false,
                       cutout: '70%',
                       plugins: {
                           legend: { display: true, position: 'bottom', labels: { color: '#003B46' } },
                           tooltip: { enabled: true }
                       }
                   }
               });
               setButtonDisabled(false);
           }, [data]);

           const handleClick = () => {
               if (chartInstance.current) {
                   chartInstance.current.data.datasets[0].data = [5, 95];
                   chartInstance.current.data.datasets[0].backgroundColor = ['#6c757d', '#E94F37'];
                   chartInstance.current.update();
                   setButtonDisabled(true);
                   onAction("Revet er helet! üòä");
               }
           };

           return (
               <div className="text-center fade-in">
                   {/* Tilf√∏jet responsive bredde og centrering til chart container */}
                   <div className="chart-container w-full max-w-xs sm:max-w-sm md:max-w-md mx-auto">
                       <canvas ref={canvasRef}></canvas>
                   </div>
                   <button onClick={handleClick} disabled={buttonDisabled} className="btn-ocean py-2 px-4 rounded-lg mt-4 block mx-auto">
                       {buttonDisabled ? onAction : data.buttonText}
                   </button>
               </div>
           );
       };

       const BarChart = ({ data }) => {
           const canvasRef = useRef(null);
           const chartInstance = useRef(null);

           useEffect(() => {
               if (chartInstance.current) {
                   chartInstance.current.destroy();
               }
               const ctx = canvasRef.current.getContext('2d');
               chartInstance.current = new Chart(ctx, {
                   type: 'bar',
                   data: {
                       labels: [data.label1, data.label2],
                       datasets: [{
                           label: 'V√¶rdi',
                           data: [data.initialValue1, data.initialValue2],
                           backgroundColor: ['#a9a9a9', '#E94F37'],
                           borderColor: '#003B46',
                           borderWidth: 2,
                           borderRadius: 5
                       }]
                   },
                   options: {
                       indexAxis: 'y',
                       responsive: true,
                       maintainAspectRatio: false,
                       plugins: { legend: { display: false } },
                       scales: {
                           x: { beginAtZero: true, max: 100, ticks: { color: '#003B46' }, grid: { color: '#003B4620' } },
                           y: { ticks: { color: '#003B46', font: { weight: 'bold' } }, grid: { display: false } }
                       }
                   }
               });
           }, [data]);

           return (
               <div className="text-center fade-in">
                   {/* Tilf√∏jet responsive bredde og centrering til chart container */}
                   <div className="chart-container w-full max-w-xs sm:max-w-sm md:max-w-md mx-auto">
                       <canvas ref={canvasRef}></canvas>
                   </div>
               </div>
           );
       };

       const InfoBox = ({ data }) => (
           <div className="info-box text-center p-4 bg-sea-deep/10 rounded-lg shadow-md fade-in">
               <span className="info-icon text-5xl mb-2 block">{data.icon || ''}</span>
               <p className="text-lg font-bold text-sea-deep">{data.text}</p>
           </div>
       );

       // --- Chapter Panel Component ---
       const ChapterPanel = ({ chapter, isOpen, onClose, onNextSection, currentSectionIndex }) => {
           const vizRef = useRef(null);
           const [vizActionMessage, setVizActionMessage] = useState('');
           const [chapterImages, setChapterImages] = useState([]);
           const [imageLoading, setImageLoading] = useState(false);
           const [imageError, setImageError] = useState('');

           // Function to generate image prompt from chapter text using Gemini
           const generateImagePrompt = async (chapterText) => {
               // Fixed description of Luca based on provided images
               const lucaDescription = "A young boy named Luca with short blonde hair and glasses, wearing casual clothes, in a child-friendly anime style.";
               
               const prompt = `Skriv en detaljeret, b√∏rnevenlig prompt til et billedgenereringsv√¶rkt√∏j, der beskriver en scene fra f√∏lgende eventyrtekst. Fokus√©r p√• hovedpersonerne (Luca, Gojo, Sukuna) og vigtige elementer/handlinger. Stilen skal v√¶re "b√∏rnevenlig anime". Prompten skal v√¶re p√• engelsk og max 150 tegn. Start med at beskrive Luca: ${lucaDescription} Teksten er: "${chapterText}"`;
               
               let chatHistory = [];
               chatHistory.push({ role: "user", parts: [{ text: prompt }] });
               const payload = { contents: chatHistory };
               const apiKey = ""; // Canvas provides this at runtime.

               const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

               try {
                   const response = await fetch(apiUrl, {
                       method: 'POST',
                       headers: { 'Content-Type': 'application/json' },
                       body: JSON.stringify(payload)
                   });
                   const result = await response.json();

                   if (result.candidates && result.candidates.length > 0 &&
                       result.candidates[0].content && result.candidates[0].content.parts &&
                       result.candidates[0].content.parts.length > 0) {
                       return result.candidates[0].content.parts[0].text;
                   } else {
                       console.error("Uventet LLM-svarstruktur for billedprompt:", result);
                       return `${lucaDescription} A scene from Luca's adventure with Gojo and Sukuna in a magical ocean.`;
                   }
               } catch (error) {
                   console.error("Fejl ved generering af billedprompt:", error);
                   return `${lucaDescription} A scene from Luca's adventure with Gojo and Sukuna in a magical ocean.`;
               }
           };

           // Function to generate images using Imagen
           const generateChapterImages = async (chapterText) => {
               setImageLoading(true);
               setImageError('');
               setChapterImages([]);

               try {
                   const imagePrompt = await generateImagePrompt(chapterText);
                   console.log("Generated Image Prompt:", imagePrompt);

                   const imageUrls = [];
                   const numberOfImages = 3; // Generate a series of 3 images

                   for (let i = 0; i < numberOfImages; i++) {
                       const payload = { instances: { prompt: imagePrompt }, parameters: { "sampleCount": 1 } };
                       const apiKey = ""; // Canvas provides this at runtime.
                       const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;

                       const response = await fetch(apiUrl, {
                           method: 'POST',
                           headers: { 'Content-Type': 'application/json' },
                           body: JSON.stringify(payload)
                       });
                       const result = await response.json();

                       if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                           const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                           imageUrls.push(imageUrl);
                       } else {
                           console.error("Uventet Imagen API-svarstruktur:", result);
                           setImageError("Kunne ikke generere alle billeder. Pr√∏v igen.");
                           break; // Stop if one image fails
                       }
                   }
                   setChapterImages(imageUrls);
               } catch (error) {
                   console.error("Fejl ved generering af kapitelbilleder:", error);
                   setImageError("Fejl ved generering af billeder: " + error.message);
               } finally {
                   setImageLoading(false);
               }
           };

           useEffect(() => {
               // Nulstil action message, n√•r kapitel √¶ndres
               setVizActionMessage('');
               setChapterImages([]); // Ryd billeder ved nyt kapitel
               setImageError(''); // Ryd fejl ved nyt kapitel
               if (isOpen && chapter) {
                   // Generate images when the panel opens for a new chapter
                   const fullChapterText = chapter.sections.map(s => s.text).join(' ');
                   generateChapterImages(fullChapterText);
               }
           }, [chapter, isOpen]); // Rerun when chapter or isOpen changes

           const handleVizAction = (message) => {
               setVizActionMessage(message);
           };

           const renderVisualization = (vizUpdate) => {
               if (!vizUpdate) return null;
               switch (vizUpdate.type) {
                   case 'doughnut':
                   case 'doughnut_update':
                       return <DoughnutChart data={vizUpdate.data} onAction={handleVizAction} />;
                   case 'pathChoice':
                   case 'pathChoice_reveal':
                       return <PathChoice onAction={handleVizAction} />;
                   case 'colorChangeDoughnut':
                   case 'colorChangeDoughnut_update':
                       return <ColorChangeDoughnut data={vizUpdate.data} onAction={handleVizAction} />;
                   case 'barChart':
                   case 'barChart_update':
                       return <BarChart data={vizUpdate.data} />;
                   case 'info':
                   case 'info_update':
                       return <InfoBox data={vizUpdate.data} />;
                   default:
                       return null;
               }
           };

           const currentSection = chapter?.sections[currentSectionIndex];

           return (
               <aside className={`chapter-panel fixed top-0 right-0 w-full md:w-1/2 lg:w-1/3 h-full bg-sea-water shadow-2xl p-4 md:p-6 z-50 flex flex-col ${isOpen ? 'is-open' : ''}`}>
                   <button onClick={onClose} className="absolute top-4 right-4 text-sea-deep text-3xl font-bold">√ó</button>
                   <div id="panel-content" className="flex-grow overflow-y-auto">
                       {chapter && (
                           <>
                               <div className="flex items-center mb-4 fade-in">
                                   <span id="chapter-icon" className="icon-large mr-4 text-sea-coral">{chapter.icon}</span>
                                   <h2 id="chapter-title" className="text-3xl font-bold text-sea-deep">{chapter.title}</h2>
                               </div>
                               <p id="chapter-intro" className="text-md text-sea-deep/80 mb-6 border-l-4 border-sea-coral pl-4 fade-in">{chapter.intro}</p>
                               <div id="chapter-viz" className="my-6 flex-shrink-0" ref={vizRef}>
                                   {currentSection && renderVisualization(currentSection.vizUpdate)}
                                   {vizActionMessage && <p className="text-center text-sea-coral mt-2 fade-in">{vizActionMessage}</p>}
                               </div>
                               <div id="chapter-text" className="text-sea-deep/90 leading-relaxed prose flex-grow fade-in">
                                   {currentSection && currentSection.text.split('\n').map((p, i) => <p key={i} className="mb-3">{p}</p>)}
                               </div>

                               {/* Image Generation Section */}
                               <div className="mt-6 pt-6 border-t border-sea-deep/20 fade-in">
                                   <h3 className="text-xl font-bold text-sea-deep mb-4">Kapitelbilleder:</h3>
                                   {imageLoading && (
                                       <div className="text-center text-sea-deep/80">
                                           <div className="loader"></div>
                                           <p>Genererer billeder...</p>
                                       </div>
                                   )}
                                   {imageError && (
                                       <p className="text-red-500 text-center mt-4">{imageError}</p>
                                   )}
                                   {!imageLoading && chapterImages.length > 0 && (
                                       <div className="image-gallery">
                                           {chapterImages.map((imageUrl, idx) => (
                                               <img key={idx} src={imageUrl} alt={`Kapitelbillede ${idx + 1}`} />
                                           ))}
                                       </div>
                                   )}
                                   {!imageLoading && chapterImages.length === 0 && !imageError && (
                                       <p className="text-sea-deep/70 text-center">Ingen billeder genereret for dette kapitel endnu.</p>
                                   )}
                               </div>
                           </>
                       )}
                   </div>
                   <div className="flex-shrink-0 mt-4">
                       <button onClick={onNextSection} className="roblox-btn green py-2 px-4 block w-full">
                           {chapter && currentSectionIndex === chapter.sections.length - 1 ? "Afslut Kapitel" : "N√¶ste"}
                       </button>
                   </div>
               </aside>
           );
       };

       // --- Customize Panel Component ---
       const CustomizePanel = ({ isOpen, onClose, onGenerateChapter, onAddChapterToMap, generationStatus, generatedChapterText, errorMessage, onResetForm }) => {
           const handleGenerateClick = () => {
               onGenerateChapter();
           };

           const handleAddClick = () => {
               onAddChapterToMap();
               onResetForm();
           };

           const handleChoiceClick = (e) => {
               e.target.classList.toggle('selected');
               e.target.classList.toggle('btn-ocean');
               e.target.classList.toggle('btn-coral');
           };

           useEffect(() => {
               if (!isOpen) {
                   onResetForm();
               }
           }, [isOpen, onResetForm]);

           return (
               <aside className={`customize-panel fixed top-0 right-0 w-full md:w-1/2 lg:w-1/3 h-full bg-sea-water shadow-2xl p-4 md:p-6 z-50 flex flex-col ${isOpen ? 'is-open' : ''}`}>
                   <button onClick={onClose} className="absolute top-4 right-4 text-sea-deep text-3xl font-bold">√ó</button>
                   <h2 className="text-3xl font-bold text-sea-deep mb-4">Skab Dit Eget Eventyr</h2>
                   <p className="text-md text-sea-deep/80 mb-6 border-l-4 border-sea-coral pl-4">Fort√¶l os, hvad Luca, Gojo og Sukuna skal opleve i n√¶ste kapitel! V√¶lg fra mulighederne eller skriv dine egne id√©er.</p>
                   
                   <div className="flex-grow overflow-y-auto mb-4">
                       <div className="mb-6">
                           <label htmlFor="custom-prompt-textarea" className="block text-lg font-semibold mb-2">Skriv din egen id√©:</label>
                           <textarea id="custom-prompt-textarea" className="w-full p-3 rounded-lg border border-sea-deep/30 bg-white/50 focus:outline-none focus:ring-2 focus:ring-sea-coral" rows="4" placeholder="F.eks. 'De m√∏der en venlig drage' eller 'De finder en skattekiste p√• bunden af havet'"></textarea>
                       </div>

                       <div className="mb-6">
                           <label className="block text-lg font-semibold mb-2">V√¶lg et dyr at m√∏de:</label>
                           <div id="animal-choices" className="grid grid-cols-2 gap-2">
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="animal:venlig delfin" onClick={handleChoiceClick}>Venlig delfin üê¨</button>
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="animal:klog bl√¶ksprutte" onClick={handleChoiceClick}>Klog bl√¶ksprutte üêô</button>
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="animal:sjov s√∏l√∏ve" onClick={handleChoiceClick}>Sjov s√∏l√∏ve ü¶≠</button>
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="animal:mystisk hval" onClick={handleChoiceClick}>Mystisk hval üê≥</button>
                           </div>
                       </div>

                       <div className="mb-6">
                           <label className="block text-lg font-semibold mb-2">V√¶lg en udfordring:</label>
                           <div id="challenge-choices" className="grid grid-cols-2 gap-2">
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="challenge:navigere gennem en storm" onClick={handleChoiceClick}>Navigere gennem en storm ‚õàÔ∏è</button>
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="challenge:finde vej i en labyrint af koralrev" onClick={handleChoiceClick}>Finde vej i koralrev üê†</button>
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="challenge:l√∏se en havg√•de for en hav√•nd" onClick={handleChoiceClick}>L√∏se en havg√•de üßú‚Äç‚ôÄÔ∏è</button>
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="challenge:hj√¶lpe et forlist skib" onClick={handleChoiceClick}>Hj√¶lpe forlist skib üö¢</button>
                           </div>
                       </div>

                       <div className="mb-6">
                           <label className="block text-lg font-semibold mb-2">V√¶lg en ny evne til Luca:</label>
                           <div id="ability-choices" className="grid grid-cols-2 gap-2">
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="ability:tale med havdyr" onClick={handleChoiceClick}>Tale med havdyr üó£Ô∏è</button>
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="ability:kontrollere vandstr√∏mme" onClick={handleChoiceClick}>Kontrollere vand üåä</button>
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="ability:se i m√∏rke under vandet" onClick={handleChoiceClick}>Se i m√∏rke üëÅÔ∏è</button>
                               <button className="choice-btn btn-ocean py-2 px-3 rounded-lg text-sm" data-choice="ability:sv√∏mme superhurtigt" onClick={handleChoiceClick}>Sv√∏mme superhurtigt üöÄ</button>
                           </div>
                       </div>
                   </div>

                   <div className="flex-shrink-0 mt-4">
                       <button onClick={handleGenerateClick} disabled={generationStatus.isLoading} className="roblox-btn py-3 px-8 block w-full">Generer N√¶ste Kapitel</button>
                       <div className={`mt-4 text-center text-sea-deep/80 ${generationStatus.isLoading ? '' : 'hidden'}`}>
                           <div className="loader"></div>
                           <p>Genererer dit kapitel...</p>
                       </div>
                       <div className={`mt-6 p-4 bg-white/70 rounded-lg shadow-inner ${generatedChapterText ? 'fade-in' : 'hidden'}`}>
                           <h3 className="text-xl font-bold text-sea-deep mb-2">Dit Nye Kapitel:</h3>
                           <div id="generated-chapter-text" className="prose text-sea-deep/90" dangerouslySetInnerHTML={{ __html: generatedChapterText }}></div>
                           <button onClick={handleAddClick} className="roblox-btn green py-2 px-4 mt-4 block mx-auto">Tilf√∏j til Kort</button>
                       </div>
                       <p className={`text-red-500 text-center mt-4 ${errorMessage ? '' : 'hidden'}`}>{errorMessage}</p>
                   </div>
               </aside>
           );
       };

       // --- Full Adventure Panel Component ---
       const FullAdventurePanel = ({ isOpen, onClose, chapters }) => {
           const contentRef = useRef(null);
           const [shareMessage, setShareMessage] = useState('');

           const handleDownloadPdf = async () => {
               setShareMessage('Forbereder PDF...');
               const input = contentRef.current;
               
               // Temporarily adjust styles for PDF generation if needed (e.g., remove overflow hidden)
               // This might be tricky with Tailwind's utility-first approach,
               // but for simple text and images, html2canvas usually handles it well.
               const originalOverflow = document.body.style.overflow;
               document.body.style.overflow = 'visible'; // Ensure all content is rendered

               try {
                   const canvas = await html2canvas(input, {
                       scale: 2, // Higher scale for better quality PDF
                       useCORS: true, // Important for images from external sources
                       logging: true,
                       scrollY: -window.scrollY, // Capture from top of the page
                       windowWidth: document.documentElement.offsetWidth,
                       windowHeight: document.documentElement.offsetHeight
                   });

                   document.body.style.overflow = originalOverflow; // Restore original overflow

                   const imgData = canvas.toDataURL('image/png');
                   const pdf = new window.jspdf.jsPDF('p', 'mm', 'a4');
                   const imgWidth = 210; // A4 width in mm
                   const pageHeight = 297; // A4 height in mm
                   const imgHeight = canvas.height * imgWidth / canvas.width;
                   let heightLeft = imgHeight;
                   let position = 0;

                   pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                   heightLeft -= pageHeight;

                   while (heightLeft >= 0) {
                       position = heightLeft - imgHeight;
                       pdf.addPage();
                       pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                       heightLeft -= pageHeight;
                   }

                   pdf.save('luca_eventyr.pdf');
                   setShareMessage('PDF downloadet! Du kan nu finde filen "luca_eventyr.pdf" i din downloads-mappe og dele den.');
               } catch (error) {
                   console.error("Fejl ved generering af PDF:", error);
                   setShareMessage('Fejl ved generering af PDF. Pr√∏v igen.');
               } finally {
                   // Reset overflow in case of error too
                   document.body.style.overflow = originalOverflow;
                   setTimeout(() => setShareMessage(''), 5000); // Clear message after 5 seconds
               }
           };

           return (
               <aside className={`full-adventure-panel fixed top-0 right-0 w-full md:w-1/2 lg:w-1/3 h-full bg-sea-water shadow-2xl p-4 md:p-6 z-50 flex flex-col ${isOpen ? 'is-open' : ''}`}>
                   <button onClick={onClose} className="absolute top-4 right-4 text-sea-deep text-3xl font-bold">√ó</button>
                   <h2 className="text-3xl font-bold text-sea-deep mb-4">Hele Dit Eventyr</h2>
                   <p className="text-md text-sea-deep/80 mb-6 border-l-4 border-sea-coral pl-4">L√¶s hele din rejse med Luca, Gojo og Sukuna fra start til slut!</p>
                   
                   <div ref={contentRef} className="flex-grow overflow-y-auto mb-4 pdf-content">
                       {chapters.map((chapter, index) => (
                           <div key={chapter.id || `full-chapter-${index}`} className="pdf-chapter mb-8 pb-6 border-b border-sea-deep/20">
                               <h3 className="text-2xl font-bold text-sea-deep mb-3">{chapter.icon} {chapter.title}</h3>
                               <p className="text-sea-deep/90 leading-relaxed mb-4">{chapter.intro}</p>
                               {chapter.sections.map((section, secIndex) => (
                                   <p key={`sec-${index}-${secIndex}`} className="text-sea-deep/90 leading-relaxed mb-3">{section.text}</p>
                               ))}
                               {/* Display images if available for the chapter */}
                               {chapter.images && chapter.images.length > 0 && (
                                   <div className="image-gallery mt-4">
                                       {chapter.images.map((imageUrl, imgIdx) => (
                                           <img key={`img-${index}-${imgIdx}`} src={imageUrl} alt={`Kapitelbillede ${index + 1}`} className="pdf-image" />
                                       ))}
                                   </div>
                               )}
                           </div>
                       ))}
                   </div>

                   <div className="flex-shrink-0 mt-4 text-center">
                       <button onClick={handleDownloadPdf} className="roblox-btn green py-3 px-8 block w-full mb-4">Download som PDF</button>
                       {shareMessage && <p className="text-sm text-sea-deep/70">{shareMessage}</p>}
                       <button onClick={onClose} className="roblox-btn red py-3 px-8 block w-full mt-2">Luk</button>
                   </div>
               </aside>
           );
       };

       // --- Main App Component ---
       const App = () => {
           const [isAuthReady, setAuthReady] = useState(false);
           const [isIntroVisible, setIsIntroVisible] = useState(true);
           const [isChapterPanelOpen, setIsChapterPanelOpen] = useState(false);
           const [isCustomizePanelOpen, setIsCustomizePanelOpen] = useState(false);
           const [isFullAdventureViewOpen, setIsFullAdventureViewOpen] = useState(false); // New state
           const [currentChapterIndex, setCurrentChapterIndex] = useState(-1);
           const [currentSectionIndex, setCurrentSectionIndex] = useState(-1);
           const [storyChapters, setStoryChapters] = useState(storyData);
           const [generatedCustomChapter, setGeneratedCustomChapter] = useState(null);
           const [generationStatus, setGenerationStatus] = useState({ isLoading: false, errorMessage: '' });

           useEffect(() => {
               FirebaseService.init(setAuthReady);
           }, []);

           useEffect(() => {
               if (isAuthReady) {
                   const unsubscribe = FirebaseService.subscribeToCustomChapters((newChapters) => {
                       setStoryChapters(prevChapters => {
                           const updatedChapters = [...prevChapters];
                           newChapters.forEach(newCh => {
                               if (!updatedChapters.some(ch => ch.id === newCh.id)) {
                                   updatedChapters.push({
                                       id: newCh.id,
                                       title: newCh.title,
                                       icon: "‚ú®",
                                       intro: newCh.intro,
                                       markerPos: { top: `${Math.random() * 80 + 10}%`, left: `${Math.random() * 80 + 10}%` },
                                       sections: [{ text: newCh.text, vizUpdate: { type: 'info', data: { text: "Dette kapitel er skabt af dig!", icon: "üåü" } } }]
                                   });
                               }
                           });
                           return updatedChapters;
                       });
                   });
                   return () => unsubscribe();
               }
           }, [isAuthReady]);

           const handleStartAdventure = () => {
               setIsIntroVisible(false);
           };

           const handleOpenChapter = (index) => {
               setCurrentChapterIndex(index);
               setCurrentSectionIndex(-1);
               setIsChapterPanelOpen(true);
               setIsCustomizePanelOpen(false); // Luk tilpasningspanel, hvis √•bent
               setIsFullAdventureViewOpen(false); // Luk fuld eventyr-visning, hvis √•ben
           };

           const handleCloseChapterPanel = () => {
               setIsChapterPanelOpen(false);
           };

           const handleNextSection = () => {
               const chapter = storyChapters[currentChapterIndex];
               if (currentSectionIndex < chapter.sections.length - 1) {
                   setCurrentSectionIndex(prev => prev + 1);
               } else {
                   setIsChapterPanelOpen(false);
               }
           };

           const handleOpenCustomizePanel = () => {
               setIsCustomizePanelOpen(true);
               setIsChapterPanelOpen(false); // Luk kapitelpanel, hvis √•bent
               setIsFullAdventureViewOpen(false); // Luk fuld eventyr-visning, hvis √•ben
           };

           const handleCloseCustomizePanel = () => {
               setIsCustomizePanelOpen(false);
           };

           const handleOpenFullAdventureView = () => {
               setIsFullAdventureViewOpen(true);
               setIsChapterPanelOpen(false);
               setIsCustomizePanelOpen(false);
           };

           const handleCloseFullAdventureView = () => {
               setIsFullAdventureViewOpen(false);
           };


           const handleGenerateChapter = async () => {
               setGenerationStatus({ isLoading: true, errorMessage: '' });
               setGeneratedCustomChapter(null);

               let customizationText = document.getElementById('custom-prompt-textarea').value.trim();
               const selectedChoices = Array.from(document.querySelectorAll('#customize-panel .choice-btn.selected')).map(btn => btn.dataset.choice);

               if (selectedChoices.length > 0) {
                   customizationText += (customizationText ? "\n" : "") + "Brugeren √∏nsker ogs√•: " + selectedChoices.join(", ");
               }

               if (!customizationText) {
                   setGenerationStatus({ isLoading: false, errorMessage: "Skriv venligst en id√© eller v√¶lg nogle muligheder." });
                   return;
               }

               const prompt = `Skriv et b√∏rnevenligt kapitel til en godnathistorie om Luca, Gojo og Sukuna. Kapitlet skal v√¶re mindst 1 side langt og skrevet i et let forst√•eligt sprog. Luca er p√• en rejse med Gojo og Sukuna for at blive den st√∏rste marine.
Brugerens √∏nsker til kapitlet:
${customizationText}
Historien skal forts√¶tte i samme tone som tidligere kapitler.`;

               let chatHistory = [];
               chatHistory.push({ role: "user", parts: [{ text: prompt }] });
               const payload = { contents: chatHistory };
               const apiKey = "";

               const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

               try {
                   const response = await fetch(apiUrl, {
                       method: 'POST',
                       headers: { 'Content-Type': 'application/json' },
                       body: JSON.stringify(payload)
                   });
                   const result = await response.json();

                   if (result.candidates && result.candidates.length > 0 &&
                       result.candidates[0].content && result.candidates[0].content.parts &&
                       result.candidates[0].content.parts.length > 0) {
                       const generatedText = result.candidates[0].content.parts[0].text;
                       setGeneratedCustomChapter({
                           title: "Dit Tilpassede Kapitel",
                           intro: "Et eventyr skabt af dine id√©er!",
                           text: generatedText,
                           timestamp: new Date()
                       });
                       setGenerationStatus({ isLoading: false, errorMessage: '' });
                   } else {
                       setGenerationStatus({ isLoading: false, errorMessage: "Kunne ikke generere kapitel. Pr√∏v venligst igen med en anden id√©." });
                       console.error("Uventet LLM-svarstruktur:", result);
                   }
               } catch (error) {
                   setGenerationStatus({ isLoading: false, errorMessage: "Fejl ved generering af kapitel: " + error.message });
                   console.error("Fejl ved LLM API-kald:", error);
               }
           };

           const handleAddChapterToMap = async () => {
               if (!generatedCustomChapter) {
                   setGenerationStatus(prev => ({ ...prev, errorMessage: "Ingen kapitel at tilf√∏je." }));
                   return;
               }

               try {
                   const chapterId = await FirebaseService.addGeneratedChapter(generatedCustomChapter);
                   if (chapterId) {
                       setStoryChapters(prevChapters => {
                           const newChapter = {
                               id: chapterId,
                               title: generatedCustomChapter.title,
                               icon: "‚ú®",
                               intro: generatedCustomChapter.intro,
                               markerPos: { top: `${Math.random() * 80 + 10}%`, left: `${Math.random() * 80 + 10}%` },
                               sections: [{ text: generatedCustomChapter.text, vizUpdate: { type: 'info', data: { text: "Dette kapitel er skabt af dig!", icon: "üåü" } } }]
                           };
                           return [...prevChapters, newChapter];
                       });
                       handleCloseCustomizePanel();
                       setGeneratedCustomChapter(null); // Ryd genereret kapitel efter tilf√∏jelse
                       // Gem fremskridt efter tilf√∏jelse af kapitel
                       FirebaseService.saveUserProgress({ lastChapterId: chapterId, lastVisited: new Date() });
                   }
               } catch (e) {
                   setGenerationStatus(prev => ({ ...prev, errorMessage: "Fejl ved lagring af kapitel: " + e.message }));
               }
           };

           const resetCustomizationForm = useCallback(() => {
               document.getElementById('custom-prompt-textarea').value = '';
               document.querySelectorAll('#customize-panel .choice-btn').forEach(btn => {
                   btn.classList.remove('selected', 'btn-coral');
                   btn.classList.add('btn-ocean');
               });
               setGeneratedCustomChapter(null);
               setGenerationStatus({ isLoading: false, errorMessage: '' });
           }, []);

           return (
               <>
                   <BackgroundCanvas />
                   {isIntroVisible ? (
                       <section id="intro-screen" className="flex-grow flex items-center justify-center p-8 text-center">
                           <div className="max-w-2xl bg-white/70 p-6 rounded-xl shadow-lg backdrop-blur-sm fade-in">
                               <h1 className="text-4xl md:text-6xl font-bold text-sea-deep mb-4">Gojo, Sukuna og det Store Hav</h1>
                               <p className="text-lg md:text-xl text-sea-deep/80 mb-8">Et interaktivt eventyr for Luca. F√∏lg med p√• en magisk rejse, l√¶r af de bedste, og bliv den st√∏rste marine, havet nogensinde har set.</p>
                               <button onClick={handleStartAdventure} className="roblox-btn green">Start Eventyret</button>
                           </div>
                       </section>
                   ) : (
                       <main id="main-app" className="flex-grow relative w-full h-full min-h-screen">
                           <DynamicWallpaper wallpaperData={wallpaperData} />
                           <LucaAvatar />
                           <div id="map-container" className="relative w-full h-full">
                               {storyChapters.map((chapter, index) => (
                                   <button
                                       key={chapter.id || `chapter-${index}`}
                                       className="map-marker absolute w-12 h-12 bg-sea-coral/80 backdrop-blur-sm rounded-full flex items-center justify-center text-white text-xl font-bold border-2 border-white shadow-lg"
                                       style={{ top: chapter.markerPos.top, left: chapter.markerPos.left }}
                                       onClick={() => handleOpenChapter(index)}
                                   >
                                       <span>{index + 1}</span>
                                   </button>
                               ))}
                           </div>
                           <div className="absolute bottom-4 left-4 flex flex-col gap-4 z-40">
                               <button onClick={handleOpenCustomizePanel} className="roblox-btn py-3 px-6">Skab Dit Eget Eventyr</button>
                               <button onClick={handleOpenFullAdventureView} className="roblox-btn green py-3 px-6">Se Hele Eventyret</button>
                           </div>

                           <ChapterPanel
                               chapter={storyChapters[currentChapterIndex]}
                               isOpen={isChapterPanelOpen}
                               onClose={handleCloseChapterPanel}
                               onNextSection={handleNextSection}
                               currentSectionIndex={currentSectionIndex}
                           />
                           <CustomizePanel
                               isOpen={isCustomizePanelOpen}
                               onClose={handleCloseCustomizePanel}
                               onGenerateChapter={handleGenerateChapter}
                               onAddChapterToMap={handleAddChapterToMap}
                               generationStatus={generationStatus}
                               generatedChapterText={generatedCustomChapter?.text}
                               errorMessage={generationStatus.errorMessage}
                               onResetForm={resetCustomizationForm}
                           />
                           <FullAdventurePanel
                               isOpen={isFullAdventureViewOpen}
                               onClose={handleCloseFullAdventureView}
                               chapters={storyChapters}
                           />
                       </main>
                   )}
               </>
           );
       };

       ReactDOM.createRoot(document.getElementById('root')).render(<App />);
   </script>
</body>
</html>
